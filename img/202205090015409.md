# Java 集合概述

![img](https://cdn.jsdelivr.net/gh/autumnmoonming/Bed/img/202205080146718.png)

> Java 集合，即容器，主要两大接口派生
>   Collection：存放单一元素
>   	List、Set、Queue
>
>   Map：存放键值对

# 1. List,Set,Queue,Map 四者区别

> List（顺序）：有序，可重复
>
> Set（独一无二）：无序，不可重复
>
> Queue（排队）：有序，可重复，按特定的排队规则来确定先后顺序
>
> Map（key）：key无序，不可重复；value无序，可重复

# 2. 集合框架底层数据结构总结

> Collection
>   List：
>   	Arraylist：Object[] 数组，适用于频繁的查找工作，线程不安全 
> 		Vector：Object[] 数组，线程安全的
> 		LinkedList：双向链表（1.6之前为循环链表，1.7取消）
>
>   Set：
>   	HashSet：（无序，唯一）基于HashMap实现
>   	LinkedHashSet：HashSet子类，内部通过LinkedHashMap实现
>   	TreeSet：（有序，唯一）红黑树（自平衡的排序二叉树）
>
>   Queue：
>   	PriorityQueue：Object[] 数组 实现二叉堆
>   	ArrayQueue：Object[] 数组 + 双指针
>
> Map
>
>   HashMap：1.8之前 数组 + 链表 组成。数组是主体，链表为了解决 哈希冲突（拉链法）。
>   				1.8以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树。转换前会判断，数组长度小于64，会先进行数组扩容
>
>   LinkedHashMap：继承自HashMap，在上面结构的基础上，增加了一条 双向链表，可以保持键值对的插入顺序，同时通过对链表进行相应操作，实现了访问顺序相关逻辑
>
>   HashTable：数组 + 链表
>
>   TreeMap：红黑树

# 3. 如何选用集合

> 根据集合特点
>   根据键值获取到元素值时就选用 Map 接口下的集合：排序时选择 TreeMap，不需要排序时就选择 HashMap，不需要排序时就选择 HashMap。
>
>   只需要存放元素值时，就选择实现Collection 接口的集合，保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet。不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。

# 4. 为什么要使用集合

> 需要保持一组类型相同的数据时，应该用一个容器来保存，就是`数组`。
>
> 实际开发中，存储的数据的类型是多种多样的。集合提高了数据存储的灵活性

# 5. ArrayLsit 与 LinkedList 区别

|                                    | ArrayLsit                                                    | LinkedList                                                   |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **是否保证线程安全**               | 不保证线程安全                                               | 不保证线程安全                                               |
| **底层数据结构**                   | **`Object` 数组**                                            | **双向链表**                                                 |
| **插入和删除是否受元素位置的影响** | 插入和删除元素的时间复杂度受元素位置的影响。默认在将指定的元素追加到此列表的末尾O(1)，指定位置 i 插入和删除元素O(n-i) | 头尾插入或者删除元素不受元素位置的影响 O(1)，指定位置 `i` 插入和删除元素的话O(n) |
| **是否支持快速随机访问**           | 支持，get(int index)                                         | 不支持高效的随机元素访问                                     |
| **内存空间占用**                   | 空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间     | 每一个元素都需要消耗比 ArrayList 更多的空间                  |

> 项目中一般是不会使用到 `LinkedList` 的，需要用到 `LinkedList` 的场景几乎都可以使用 `ArrayList` 来代替，并且，性能通常会更好！
>
> 另外，不要下意识地认为 `LinkedList` 作为链表就最适合元素增删的场景。`LinkedList` 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 

